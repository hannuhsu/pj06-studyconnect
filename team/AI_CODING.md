Zhenyu Yu: I used ChatGPT to help me reuse the ClassesSidebar component from the home page for the courses page. I knew I wanted something similar on the courses page, and wanted to reuse the component, but didn't know exactly how to refactor the page and the component so that the component would work on both pages. I sent ChatGPT the component code and asked it to refactor it so that it would update as users added and removed courses from their joined list on the courses page without breaking functionality while on the home page. ChatGPT was able to do this really quickly and the result was a properly refactored component usable on both pages. To ensure the output was correct, I had to manually test that both pages were working as intended afterwards. I also had it explain to me what it changed so I can check the differences and ensure it was understandable and correct. To make it more accurate, I only sent in the component's code and explained the functionality I wanted it to have on both pages, instead of also sending in the pages' code. I think this was extremely helpful and will be helpful in my future coding efforts by helping me refactor code to be used in multiple places and also to understand older code for refactoring or changing. It can also be useful just to ask it to explain parts of older code to get refamiliarized with it quickly especially as the codebase expands.

Wesley Chiba: I have been using GitHub Copilot for a while now, but for this lab05 I used it to help me create some basic Jest unit tests to help verify the functionality of our webapp. It was good at getting down the basics of setting up unit testing such as installing the proper libraries and dependencies, but I found it difficult to get it to work with our specific setup. However I was able to get it to work in the end, and was able to implement unit tests that were able to test both the frontend and backend portions of the pages. From my experience, I see that generative AI is good at giving you a foundation to work on for various libraries that you may not have experience in, as it was able to generate a few functional tests for a library I have never used before. Without generative AI, I would have had to thoroughly go through the documentation for the library and even then it may not work with our specific setup. Although generative AI is easy to use, I think it is important to still verify that the code you integrate into your project is correct as some of the code may not work for your project or cause issues with other components.

Maria Saucedo-Flores: I used v0.dev by Vercel to experiment with implementing a chatbox component that could be integrated alongside the forum posting one for each class to have its own chat, and I used DeepSeek to explain WebSockets to me, as well as how to retain memory of the previous chats with Firebase. Currently, I do not have a way to test it's functionality with the rest of our webapp on my own yet, as my Chromebook stopped functioning this week, but v0.dev produced a live demo of the code it generated and how it would look, and was even able to apply profile pictures next to the messages depending on who sent them. I checked that v0's code was free use by going to their website, and while it has limits on how many times you can chat with their bot unless you pay for premium plans and uses your messages for data-training, it is okay to use the code it generates. Being able to ask how and why certain features are implemented the way they are is very useful in understanding how the code works, and while I don't think all of our code should or will be generated by AI, using it to speed up the process of functionality is useful and lets us spend more time making sure the website looks and acts exactly like we want it to, and lets us focus on the aspects of the webapp that users will interact with. 

Shelly Zhu: I used Cursor to help me write the code for the class forum and post page. I asked it to help me structure the components and implement the functionality for users to create, view, and interact with forum posts for each class. Cursor was particularly helpful in suggesting efficient ways to organize the data structure and handle state management for the forum posts. When implementing features like post creation and comment threading, Cursor provided code suggestions that aligned well with our existing codebase patterns. To ensure the AI-generated code was correct, I had to carefully review each suggestion, test the functionality thoroughly, and make adjustments to match our specific requirements and styling. I found that Cursor works best when you have a clear idea of what you want to build and can provide specific context about your existing codebase. While it significantly sped up the initial implementation process, it was crucial to validate the code's security, especially around user authentication and data handling. Going forward, I think Cursor will be most valuable for getting quick implementations of common patterns and boilerplate code, but should be used alongside careful code review and testing to ensure quality and security.

Allen Hu: I used GitHub Copilot to modify the create-profile page. Previously, the page overwrites the user info's every data entry with their inputs, and also set the joinedClasses column to an empty list. However, if the user has already joined some classes, then once it uploads the profile, the previously joined classes will be overwritten. So I asked Copilot to read my code, update the logic of it such that it first tries to fetch the user's data from DB, and when the user submit new info, check whether the joinedClasses list is empty. If not, do not update it. Then Copilot quickly updated my code based on my prompt, and it completed the task well. I think one of the key idea in cooperation with AI is to break down an issue into several small tasks. The best case is that you understand the project and what you are doing, then you introduce the context first, and directly tell the AI what to do, not asking it, and test the new codes before moving on to the next small task. The copilots might also perform better if you already have some functioning codes and ask them to do some modification after understanding the existing codes, such that their behavior will be more controllable compared to starting from scratch. 

Anthony Jin: I experimented with ChatGPT to group and target specific work areas based on MVP feedback, as well as provide a prioritized list of next steps. This tool was very useful in providing a comprehensive summary of main feedback points from the feedback, and could help to provide direction for future features and areas of improvement based on our MVP demo. To ensure the AI-grouped feedback was accurate, I cross-checked all feedback against the original MVP feedback and made sure there were no hallucinations. I also played around with the prompt, incorporating terms like "group and highlight most relevant based on occurrence" versus just "group feedback", finding that the more specific I got with my prompts, the more conduicive the results were to my/the team's needs. Finally, requesting prioritized next steps did result in a workable list; however, the priority never completely aligned with the team's needs, though it was always roughly accurate. 

Hannah Su:  I used ChatGPT to help me understand OAuth capabilities and how to exten OAuth with OpenID Connect to enable SSO. ChatGPT is very helpful in giving me the necessary information to integrate OAuth and its potential. Then, I have ChatGPT help me research various OAuth libraries and help me decide on which one to use. Afterwards, I did my own reserach and found that the suggestion that ChatGPT gave me is what most people advoicate to use. Next, I prompted ChatGPT to write some code to integrate with our existing codebase, however the code that ChatGPT gave me was riddle with bugs and sometimes incompatiable with our code. In conclusion, I think ChatGPT works best when conducting surface level research into a new topic, however its usefulness quickly degrades when asked to perform complex tasks like code analysis and generation.
